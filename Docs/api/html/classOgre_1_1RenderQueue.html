<html>
<head>
<title>Ogre::RenderQueue Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>
<body>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOgre.html">Ogre</a></li><li class="navelem"><a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classOgre_1_1RenderQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::RenderQueue Class Reference<div class="ingroups"><a class="el" href="group__RenderSystem.html">RenderSystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to manage the scene object rendering queue.  
 <a href="classOgre_1_1RenderQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::RenderQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classOgre_1_1RenderQueue__inherit__graph.png" border="0" usemap="#Ogre_1_1RenderQueue_inherit__map" alt="Inheritance graph"/></div>
<map name="Ogre_1_1RenderQueue_inherit__map" id="Ogre_1_1RenderQueue_inherit__map">
<area shape="rect" id="node2" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator..." alt="" coords="8,5,139,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to listen in on items being added to the render queue.  <a href="classOgre_1_1RenderQueue_1_1RenderableListener.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add383352b6e187bfd9ee4f09753df493"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#add383352b6e187bfd9ee4f09753df493">ConstQueueGroupIterator</a></td></tr>
<tr class="separator:add383352b6e187bfd9ee4f09753df493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf42f3f073ba37a87a555e37143ed1e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4cf42f3f073ba37a87a555e37143ed1e">QueueGroupIterator</a></td></tr>
<tr class="memdesc:a4cf42f3f073ba37a87a555e37143ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over queue groups.  <a href="#a4cf42f3f073ba37a87a555e37143ed1e">More...</a><br/></td></tr>
<tr class="separator:a4cf42f3f073ba37a87a555e37143ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72db2e13a4ff894459d361bee8e85fdf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1map.html">map</a>&lt; <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>, <br class="typebreak"/>
<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a></td></tr>
<tr class="separator:a72db2e13a4ff894459d361bee8e85fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5454a3907c8ce62ab9454b7e4e6ef818"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a5454a3907c8ce62ab9454b7e4e6ef818">RenderQueue</a> ()</td></tr>
<tr class="separator:a5454a3907c8ce62ab9454b7e4e6ef818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15db5053b0d5bbd21cf9e797ea06f0d9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a15db5053b0d5bbd21cf9e797ea06f0d9">~RenderQueue</a> ()</td></tr>
<tr class="separator:a15db5053b0d5bbd21cf9e797ea06f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e66972499413f4f911ab3dfcf0412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue.html#a4cf42f3f073ba37a87a555e37143ed1e">QueueGroupIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a591e66972499413f4f911ab3dfcf0412">_getQueueGroupIterator</a> (void)</td></tr>
<tr class="memdesc:a591e66972499413f4f911ab3dfcf0412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method, returns an iterator for the queue groups.  <a href="#a591e66972499413f4f911ab3dfcf0412">More...</a><br/></td></tr>
<tr class="separator:a591e66972499413f4f911ab3dfcf0412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdfde9ce4912ab70f28bd5cc02e198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue.html#add383352b6e187bfd9ee4f09753df493">ConstQueueGroupIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a70fdfde9ce4912ab70f28bd5cc02e198">_getQueueGroupIterator</a> (void) const </td></tr>
<tr class="separator:a70fdfde9ce4912ab70f28bd5cc02e198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb30e0dd6cd6db7f74650d311a68013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aedb30e0dd6cd6db7f74650d311a68013">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend, <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> groupID, <a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> priority)</td></tr>
<tr class="memdesc:aedb30e0dd6cd6db7f74650d311a68013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#aedb30e0dd6cd6db7f74650d311a68013">More...</a><br/></td></tr>
<tr class="separator:aedb30e0dd6cd6db7f74650d311a68013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b67aff41b50d24cef0420871ce6f3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a8b67aff41b50d24cef0420871ce6f3af">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend, <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> groupId)</td></tr>
<tr class="memdesc:a8b67aff41b50d24cef0420871ce6f3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#a8b67aff41b50d24cef0420871ce6f3af">More...</a><br/></td></tr>
<tr class="separator:a8b67aff41b50d24cef0420871ce6f3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8caa5feac9cee401f34f5aa1918d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#acc8caa5feac9cee401f34f5aa1918d0d">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend)</td></tr>
<tr class="memdesc:acc8caa5feac9cee401f34f5aa1918d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#acc8caa5feac9cee401f34f5aa1918d0d">More...</a><br/></td></tr>
<tr class="separator:acc8caa5feac9cee401f34f5aa1918d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7351e9922649a71a54fb5b0ccfb525c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a7351e9922649a71a54fb5b0ccfb525c4">clear</a> (bool destroyPassMaps=false)</td></tr>
<tr class="memdesc:a7351e9922649a71a54fb5b0ccfb525c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue - should only be called by SceneManagers.  <a href="#a7351e9922649a71a54fb5b0ccfb525c4">More...</a><br/></td></tr>
<tr class="separator:a7351e9922649a71a54fb5b0ccfb525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab263254bd0c13a91c44d5fafd18c16c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#ab263254bd0c13a91c44d5fafd18c16c3">getDefaultQueueGroup</a> (void) const </td></tr>
<tr class="memdesc:ab263254bd0c13a91c44d5fafd18c16c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <a href="#ab263254bd0c13a91c44d5fafd18c16c3">More...</a><br/></td></tr>
<tr class="separator:ab263254bd0c13a91c44d5fafd18c16c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3903367113d6a51591ad16faeb17e8e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a3903367113d6a51591ad16faeb17e8e0">getDefaultRenderablePriority</a> (void) const </td></tr>
<tr class="memdesc:a3903367113d6a51591ad16faeb17e8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <a href="#a3903367113d6a51591ad16faeb17e8e0">More...</a><br/></td></tr>
<tr class="separator:a3903367113d6a51591ad16faeb17e8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d85342418d78d733f887530e73da1c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a6d85342418d78d733f887530e73da1c0">getQueueGroup</a> (<a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>
<tr class="memdesc:a6d85342418d78d733f887530e73da1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a render queue group.  <a href="#a6d85342418d78d733f887530e73da1c0">More...</a><br/></td></tr>
<tr class="separator:a6d85342418d78d733f887530e73da1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0833e163d52c2fffef84dfe81af1606a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a0833e163d52c2fffef84dfe81af1606a">getRenderableListener</a> (void) const </td></tr>
<tr class="separator:a0833e163d52c2fffef84dfe81af1606a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21bd8a507d984603dbb252e42c949d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4b21bd8a507d984603dbb252e42c949d">getShadowCastersCannotBeReceivers</a> (void) const </td></tr>
<tr class="memdesc:a4b21bd8a507d984603dbb252e42c949d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Gets whether or not objects which cast shadows should be treated as
</pre><p> never receiving shadows.  <a href="#a4b21bd8a507d984603dbb252e42c949d">More...</a><br/></td></tr>
<tr class="separator:a4b21bd8a507d984603dbb252e42c949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7465cff6abb0c131efcc5d637a6d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a09c7465cff6abb0c131efcc5d637a6d4">getSplitNoShadowPasses</a> (void) const </td></tr>
<tr class="memdesc:a09c7465cff6abb0c131efcc5d637a6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Gets whether or not the queue will split passes which have shadow receive
</pre><p> turned off (in their parent material), which is needed when certain shadow techniques are used.  <a href="#a09c7465cff6abb0c131efcc5d637a6d4">More...</a><br/></td></tr>
<tr class="separator:a09c7465cff6abb0c131efcc5d637a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c88b94513eac36f4128567f90b7c37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a77c88b94513eac36f4128567f90b7c37">getSplitPassesByLightingType</a> (void) const </td></tr>
<tr class="memdesc:a77c88b94513eac36f4128567f90b7c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <a href="#a77c88b94513eac36f4128567f90b7c37">More...</a><br/></td></tr>
<tr class="separator:a77c88b94513eac36f4128567f90b7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55552364f1a8ecb2fb9a166ef92e070a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a55552364f1a8ecb2fb9a166ef92e070a">merge</a> (const <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *rhs)</td></tr>
<tr class="memdesc:a55552364f1a8ecb2fb9a166ef92e070a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge render queue.  <a href="#a55552364f1a8ecb2fb9a166ef92e070a">More...</a><br/></td></tr>
<tr class="separator:a55552364f1a8ecb2fb9a166ef92e070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br/></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br/></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br/></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af90d52791616e975fc0da4dc1ec78e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a5af90d52791616e975fc0da4dc1ec78e">processVisibleObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mo, <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, bool onlyShadowCasters, <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *visibleBounds)</td></tr>
<tr class="memdesc:a5af90d52791616e975fc0da4dc1ec78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to perform the standard actions associated with getting a visible object to add itself to the queue.  <a href="#a5af90d52791616e975fc0da4dc1ec78e">More...</a><br/></td></tr>
<tr class="separator:a5af90d52791616e975fc0da4dc1ec78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee86531136c2069ab7ed03ec8802b624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aee86531136c2069ab7ed03ec8802b624">setDefaultQueueGroup</a> (<a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> grp)</td></tr>
<tr class="memdesc:aee86531136c2069ab7ed03ec8802b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <a href="#aee86531136c2069ab7ed03ec8802b624">More...</a><br/></td></tr>
<tr class="separator:aee86531136c2069ab7ed03ec8802b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5d94b3d357524a08affce11c383374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aeb5d94b3d357524a08affce11c383374">setDefaultRenderablePriority</a> (<a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> priority)</td></tr>
<tr class="memdesc:aeb5d94b3d357524a08affce11c383374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <a href="#aeb5d94b3d357524a08affce11c383374">More...</a><br/></td></tr>
<tr class="separator:aeb5d94b3d357524a08affce11c383374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4830aa759ae0619a637dc979f8f0d581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4830aa759ae0619a637dc979f8f0d581">setRenderableListener</a> (<a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *listener)</td></tr>
<tr class="memdesc:a4830aa759ae0619a637dc979f8f0d581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a renderable listener on the queue.  <a href="#a4830aa759ae0619a637dc979f8f0d581">More...</a><br/></td></tr>
<tr class="separator:a4830aa759ae0619a637dc979f8f0d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a571f752196f24799e5aebb6bd715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aac9a571f752196f24799e5aebb6bd715">setShadowCastersCannotBeReceivers</a> (bool ind)</td></tr>
<tr class="memdesc:aac9a571f752196f24799e5aebb6bd715"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Sets whether or not objects which cast shadows should be treated as
</pre><p> never receiving shadows.  <a href="#aac9a571f752196f24799e5aebb6bd715">More...</a><br/></td></tr>
<tr class="separator:aac9a571f752196f24799e5aebb6bd715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edec1309abf170a0dd09612911fc4bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4edec1309abf170a0dd09612911fc4bc">setSplitNoShadowPasses</a> (bool split)</td></tr>
<tr class="memdesc:a4edec1309abf170a0dd09612911fc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">Sets whether or not the queue will split passes which have shadow receive
</pre><p> turned off (in their parent material), which is needed when certain shadow techniques are used.  <a href="#a4edec1309abf170a0dd09612911fc4bc">More...</a><br/></td></tr>
<tr class="separator:a4edec1309abf170a0dd09612911fc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c00d063c95049da895c7bfc8923311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a12c00d063c95049da895c7bfc8923311">setSplitPassesByLightingType</a> (bool split)</td></tr>
<tr class="memdesc:a12c00d063c95049da895c7bfc8923311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <a href="#a12c00d063c95049da895c7bfc8923311">More...</a><br/></td></tr>
<tr class="separator:a12c00d063c95049da895c7bfc8923311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7166e043e0913cb1e08e4737befce3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a7166e043e0913cb1e08e4737befce3f6">mDefaultQueueGroup</a></td></tr>
<tr class="memdesc:a7166e043e0913cb1e08e4737befce3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current default queue group.  <a href="#a7166e043e0913cb1e08e4737befce3f6">More...</a><br/></td></tr>
<tr class="separator:a7166e043e0913cb1e08e4737befce3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e1472401b4e1d24676e60d41b4705d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#af1e1472401b4e1d24676e60d41b4705d">mDefaultRenderablePriority</a></td></tr>
<tr class="memdesc:af1e1472401b4e1d24676e60d41b4705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default priority.  <a href="#af1e1472401b4e1d24676e60d41b4705d">More...</a><br/></td></tr>
<tr class="separator:af1e1472401b4e1d24676e60d41b4705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91a53059c0a0f61c07d3a0753a3bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aaf91a53059c0a0f61c07d3a0753a3bfe">mGroups</a></td></tr>
<tr class="separator:aaf91a53059c0a0f61c07d3a0753a3bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07814ff649c3a7a914fa3961a83a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#add07814ff649c3a7a914fa3961a83a3d">mRenderableListener</a></td></tr>
<tr class="separator:add07814ff649c3a7a914fa3961a83a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb15a31918778ed0e0c74aacf3358f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#abfb15a31918778ed0e0c74aacf3358f6">mShadowCastersCannotBeReceivers</a></td></tr>
<tr class="separator:abfb15a31918778ed0e0c74aacf3358f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66986fa9c851664d568e3dbb5a2d40cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a66986fa9c851664d568e3dbb5a2d40cb">mSplitNoShadowPasses</a></td></tr>
<tr class="separator:a66986fa9c851664d568e3dbb5a2d40cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5adba44e7d9c936efcb35d389d5bb58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#af5adba44e7d9c936efcb35d389d5bb58">mSplitPassesByLightingType</a></td></tr>
<tr class="separator:af5adba44e7d9c936efcb35d389d5bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to manage the scene object rendering queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Objects are grouped by material to minimise rendering state changes. The map from material to renderable object is wrapped in a class for ease of use. </dd></dl>
<dl class="section user"><dt></dt><dd>This class now includes the concept of 'queue groups' which allows the application adding the renderable to specifically schedule it so that it is included in a discrete group. Good for separating renderables into the main scene, backgrounds and overlays, and also could be used in the future for more complex multipass routines like stenciling. </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00092">92</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="add383352b6e187bfd9ee4f09753df493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a>&lt;<a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&gt; <a class="el" href="classOgre_1_1RenderQueue.html#add383352b6e187bfd9ee4f09753df493">Ogre::RenderQueue::ConstQueueGroupIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00099">99</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf42f3f073ba37a87a555e37143ed1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&gt; <a class="el" href="classOgre_1_1RenderQueue.html#a4cf42f3f073ba37a87a555e37143ed1e">Ogre::RenderQueue::QueueGroupIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over queue groups. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00098">98</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72db2e13a4ff894459d361bee8e85fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1map.html">map</a>&lt; <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>, <a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a>* &gt;::type <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">Ogre::RenderQueue::RenderQueueGroupMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00096">96</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5454a3907c8ce62ab9454b7e4e6ef818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::RenderQueue::RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15db5053b0d5bbd21cf9e797ea06f0d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::RenderQueue::~RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a591e66972499413f4f911ab3dfcf0412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue.html#a4cf42f3f073ba37a87a555e37143ed1e">QueueGroupIterator</a> Ogre::RenderQueue::_getQueueGroupIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method, returns an iterator for the queue groups. </p>

</div>
</div>
<a class="anchor" id="a70fdfde9ce4912ab70f28bd5cc02e198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue.html#add383352b6e187bfd9ee4f09753df493">ConstQueueGroupIterator</a> Ogre::RenderQueue::_getQueueGroupIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aedb30e0dd6cd6db7f74650d311a68013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>groupID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the advanced version of the call which allows the renderable to be added to any queue. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td class="paramname">groupID</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
    <tr><td class="paramname">priority</td><td>Controls the priority of the renderable within the queue group. If this number is raised, the renderable will be rendered later in the group compared to it's peers. Don't use this unless you really need to, manually ordering renderables prevents OGRE from sorting them for best efficiency. However this could be useful for ordering 2D elements manually for example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b67aff41b50d24cef0420871ce6f3af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>groupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the simplified version of the call which does not require a priority to be specified. The queue priority is take from the current default (see setDefaultRenderablePriority). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td class="paramname">groupId</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8caa5feac9cee401f34f5aa1918d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>pRend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the simplified version of the call which does not require a queue or priority to be specified. The queue group is taken from the current default (see setDefaultQueueGroup). The queue priority is take from the current default (see setDefaultRenderablePriority). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRend</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7351e9922649a71a54fb5b0ccfb525c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroyPassMaps</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the queue - should only be called by SceneManagers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destroyPassMaps</td><td>Set to true to destroy all pass maps so that the queue is completely clean (useful when switching scene managers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab263254bd0c13a91c44d5fafd18c16c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::RenderQueue::getDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>

</div>
</div>
<a class="anchor" id="a3903367113d6a51591ad16faeb17e8e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> Ogre::RenderQueue::getDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a class="anchor" id="a6d85342418d78d733f887530e73da1c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a>* Ogre::RenderQueue::getQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>qid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a render queue group. </p>
<dl class="section remark"><dt>Remarks</dt><dd>OGRE registers new queue groups as they are requested, therefore this method will always return a valid group. </dd></dl>

</div>
</div>
<a class="anchor" id="a0833e163d52c2fffef84dfe81af1606a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a>* Ogre::RenderQueue::getRenderableListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00286">286</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b21bd8a507d984603dbb252e42c949d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><pre class="fragment">Gets whether or not objects which cast shadows should be treated as
</pre><p> never receiving shadows. </p>

</div>
</div>
<a class="anchor" id="a09c7465cff6abb0c131efcc5d637a6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><pre class="fragment">Gets whether or not the queue will split passes which have shadow receive
</pre><p> turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a class="anchor" id="a77c88b94513eac36f4128567f90b7c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<a class="anchor" id="a55552364f1a8ecb2fb9a166ef92e070a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge render queue. </p>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00096">96</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00102">102</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00108">108</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00113">113</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00119">119</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00068">68</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00073">73</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00079">79</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00086">86</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00091">91</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5af90d52791616e975fc0da4dc1ec78e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::processVisibleObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyShadowCasters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *&#160;</td>
          <td class="paramname"><em>visibleBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to perform the standard actions associated with getting a visible object to add itself to the queue. </p>
<p>This is a replacement for <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementations of the associated tasks related to calling <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </p>

</div>
</div>
<a class="anchor" id="aee86531136c2069ab7ed03ec8802b624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>
<p>See the enum RenderQueueGroupID for what kind of values can be used here. </p>

</div>
</div>
<a class="anchor" id="aeb5d94b3d357524a08affce11c383374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a class="anchor" id="a4830aa759ae0619a637dc979f8f0d581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setRenderableListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a renderable listener on the queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>There can only be a single renderable listener on the queue, since that listener has complete control over the techniques in use. </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00283">283</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac9a571f752196f24799e5aebb6bd715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><pre class="fragment">Sets whether or not objects which cast shadows should be treated as
</pre><p> never receiving shadows. </p>

</div>
</div>
<a class="anchor" id="a4edec1309abf170a0dd09612911fc4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><pre class="fragment">Sets whether or not the queue will split passes which have shadow receive
</pre><p> turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a class="anchor" id="a12c00d063c95049da895c7bfc8923311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7166e043e0913cb1e08e4737befce3f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::RenderQueue::mDefaultQueueGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current default queue group. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00137">137</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1e1472401b4e1d24676e60d41b4705d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> Ogre::RenderQueue::mDefaultRenderablePriority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default priority. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00139">139</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf91a53059c0a0f61c07d3a0753a3bfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> Ogre::RenderQueue::mGroups</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00135">135</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="add07814ff649c3a7a914fa3961a83a3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a>* Ogre::RenderQueue::mRenderableListener</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00145">145</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="abfb15a31918778ed0e0c74aacf3358f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::mShadowCastersCannotBeReceivers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00143">143</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66986fa9c851664d568e3dbb5a2d40cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::mSplitNoShadowPasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00142">142</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5adba44e7d9c936efcb35d389d5bb58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::mSplitPassesByLightingType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00141">141</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<p>
Copyright &copy; 2012 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->
Last modified Mon Nov 25 2013 22:28:08
</p>
</body>
</html>
