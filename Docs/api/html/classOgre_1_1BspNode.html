<html>
<head>
<title>Ogre::BspNode Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>
<body>
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOgre.html">Ogre</a></li><li class="navelem"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOgre_1_1BspNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::BspNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a node in a BSP tree.  
 <a href="classOgre_1_1BspNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::BspNode:</div>
<div class="dyncontent">
<div class="center"><img src="classOgre_1_1BspNode__inherit__graph.png" border="0" usemap="#Ogre_1_1BspNode_inherit__map" alt="Inheritance graph"/></div>
<map name="Ogre_1_1BspNode_inherit__map" id="Ogre_1_1BspNode_inherit__map">
<area shape="rect" id="node2" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator..." alt="" coords="19,5,100,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af86ad5b76b6e2327db0e702d4216ad30"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1set.html">set</a>&lt; const <br class="typebreak"/>
<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a></td></tr>
<tr class="separator:af86ad5b76b6e2327db0e702d4216ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt; <a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a></td></tr>
<tr class="separator:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39b74504f7252462d27f69bbeef5dc99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a39b74504f7252462d27f69bbeef5dc99">BspNode</a> (<a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *owner, bool <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533">isLeaf</a>)</td></tr>
<tr class="memdesc:a39b74504f7252462d27f69bbeef5dc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, only to be used by <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a>.  <a href="#a39b74504f7252462d27f69bbeef5dc99">More...</a><br/></td></tr>
<tr class="separator:a39b74504f7252462d27f69bbeef5dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10395588ed29a1d34e3b028643dd2d77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a10395588ed29a1d34e3b028643dd2d77">BspNode</a> ()</td></tr>
<tr class="separator:a10395588ed29a1d34e3b028643dd2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74871a4318ee6f0bfdf068a988bc2496"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a74871a4318ee6f0bfdf068a988bc2496">~BspNode</a> ()</td></tr>
<tr class="separator:a74871a4318ee6f0bfdf068a988bc2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5702538be4c791af37cd73d2aa353a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ac5702538be4c791af37cd73d2aa353a5">_addMovable</a> (const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:ac5702538be4c791af37cd73d2aa353a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable intersects it.  <a href="#ac5702538be4c791af37cd73d2aa353a5">More...</a><br/></td></tr>
<tr class="separator:ac5702538be4c791af37cd73d2aa353a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10efd90b923c891eba69bad3b06d450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#aa10efd90b923c891eba69bad3b06d450">_removeMovable</a> (const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:aa10efd90b923c891eba69bad3b06d450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable no longer intersects it.  <a href="#aa10efd90b923c891eba69bad3b06d450">More...</a><br/></td></tr>
<tr class="separator:aa10efd90b923c891eba69bad3b06d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ac32f7f2ef7940f9f1236fdc6b17063ef">getBack</a> (void) const </td></tr>
<tr class="memdesc:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> containing the subspace on the negative side of the splitting plane.  <a href="#ac32f7f2ef7940f9f1236fdc6b17063ef">More...</a><br/></td></tr>
<tr class="separator:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ab257ed1ca61d08ca730acfdeb9d660c1">getBoundingBox</a> (void) const </td></tr>
<tr class="memdesc:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the axis-aligned box which contains this node if it is a leaf.  <a href="#ab257ed1ca61d08ca730acfdeb9d660c1">More...</a><br/></td></tr>
<tr class="separator:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210e41df7ecc16925b72a1be860eaf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a210e41df7ecc16925b72a1be860eaf1d">getDistance</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;pos) const </td></tr>
<tr class="memdesc:a210e41df7ecc16925b72a1be860eaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the signed distance to the dividing plane.  <a href="#a210e41df7ecc16925b72a1be860eaf1d">More...</a><br/></td></tr>
<tr class="separator:a210e41df7ecc16925b72a1be860eaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d74a62b0962ada93a3354d502365a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ac4d74a62b0962ada93a3354d502365a7">getFaceGroupStart</a> (void) const </td></tr>
<tr class="memdesc:ac4d74a62b0962ada93a3354d502365a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the face group index list for this leaf node.  <a href="#ac4d74a62b0962ada93a3354d502365a7">More...</a><br/></td></tr>
<tr class="separator:ac4d74a62b0962ada93a3354d502365a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70415637b4144d7540113c8f0976bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a1a70415637b4144d7540113c8f0976bb">getFront</a> (void) const </td></tr>
<tr class="memdesc:a1a70415637b4144d7540113c8f0976bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> containing the subspace on the positive side of the splitting plane.  <a href="#a1a70415637b4144d7540113c8f0976bb">More...</a><br/></td></tr>
<tr class="separator:a1a70415637b4144d7540113c8f0976bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ef32ad301c2cf1b427f762503b72a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a02ef32ad301c2cf1b427f762503b72a3">getNextNode</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;point) const </td></tr>
<tr class="memdesc:a02ef32ad301c2cf1b427f762503b72a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next node down in the tree, with the intention of locating the leaf containing the given point.  <a href="#a02ef32ad301c2cf1b427f762503b72a3">More...</a><br/></td></tr>
<tr class="separator:a02ef32ad301c2cf1b427f762503b72a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e24765e11c6b8efc03db7d1043070d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a0e24765e11c6b8efc03db7d1043070d0">getNumFaceGroups</a> (void) const </td></tr>
<tr class="memdesc:a0e24765e11c6b8efc03db7d1043070d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of faces contained in this leaf node.  <a href="#a0e24765e11c6b8efc03db7d1043070d0">More...</a><br/></td></tr>
<tr class="separator:a0e24765e11c6b8efc03db7d1043070d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33233f828bbdf5b7160a70e463c4157"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#aa33233f828bbdf5b7160a70e463c4157">getObjects</a> (void) const </td></tr>
<tr class="separator:aa33233f828bbdf5b7160a70e463c4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a64fbeed3630e8bddb0ed3fba99f373c9">getSide</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;point) const </td></tr>
<tr class="memdesc:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which side of the splitting plane a worldspace point is.  <a href="#a64fbeed3630e8bddb0ed3fba99f373c9">More...</a><br/></td></tr>
<tr class="separator:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9df00126e7fd14b6552788b8f5542"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#aeec9df00126e7fd14b6552788b8f5542">getSolidBrushes</a> (void) const </td></tr>
<tr class="memdesc:aeec9df00126e7fd14b6552788b8f5542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main brush memory held on level.  <a href="#aeec9df00126e7fd14b6552788b8f5542">More...</a><br/></td></tr>
<tr class="separator:aeec9df00126e7fd14b6552788b8f5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138be75d58af8407ff8eb581ef1acead"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a138be75d58af8407ff8eb581ef1acead">getSplitPlane</a> (void) const </td></tr>
<tr class="memdesc:a138be75d58af8407ff8eb581ef1acead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the plane which is used to subdivide the space of his node's children.  <a href="#a138be75d58af8407ff8eb581ef1acead">More...</a><br/></td></tr>
<tr class="separator:a138be75d58af8407ff8eb581ef1acead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f25a54f243b0bed44f446e92af533"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533">isLeaf</a> (void) const </td></tr>
<tr class="memdesc:a5c3f25a54f243b0bed44f446e92af533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is a leaf (i.e.  <a href="#a5c3f25a54f243b0bed44f446e92af533">More...</a><br/></td></tr>
<tr class="separator:a5c3f25a54f243b0bed44f446e92af533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851252ff648cb129cf8cb87cd7b45783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a851252ff648cb129cf8cb87cd7b45783">isLeafVisible</a> (const <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *leaf) const </td></tr>
<tr class="memdesc:a851252ff648cb129cf8cb87cd7b45783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the passed in node (must also be a leaf) is visible from this leaf.  <a href="#a851252ff648cb129cf8cb87cd7b45783">More...</a><br/></td></tr>
<tr class="separator:a851252ff648cb129cf8cb87cd7b45783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br/></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br/></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br/></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aaeaabf9f30966c28d7131a4e4d0f496b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#aaeaabf9f30966c28d7131a4e4d0f496b">mBack</a></td></tr>
<tr class="memdesc:aaeaabf9f30966c28d7131a4e4d0f496b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the node behind this non-leaf node.  <a href="#aaeaabf9f30966c28d7131a4e4d0f496b">More...</a><br/></td></tr>
<tr class="separator:aaeaabf9f30966c28d7131a4e4d0f496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2fd9dac5864edd6169b3e9d188dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a36a2fd9dac5864edd6169b3e9d188dda">mBounds</a></td></tr>
<tr class="memdesc:a36a2fd9dac5864edd6169b3e9d188dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The axis-aligned box which bounds node if it is a leaf.  <a href="#a36a2fd9dac5864edd6169b3e9d188dda">More...</a><br/></td></tr>
<tr class="separator:a36a2fd9dac5864edd6169b3e9d188dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8268f4997a3e9d91fcd2a1f8aeee3b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ac8268f4997a3e9d91fcd2a1f8aeee3b9">mFaceGroupStart</a></td></tr>
<tr class="memdesc:ac8268f4997a3e9d91fcd2a1f8aeee3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to the part of the main leaf facegroup index buffer(held in BspLevel) for this leaf.  <a href="#ac8268f4997a3e9d91fcd2a1f8aeee3b9">More...</a><br/></td></tr>
<tr class="separator:ac8268f4997a3e9d91fcd2a1f8aeee3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e71ff943c560f8603242f47db40478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ae8e71ff943c560f8603242f47db40478">mFront</a></td></tr>
<tr class="memdesc:ae8e71ff943c560f8603242f47db40478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the node in front of this non-leaf node.  <a href="#ae8e71ff943c560f8603242f47db40478">More...</a><br/></td></tr>
<tr class="separator:ae8e71ff943c560f8603242f47db40478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0862d80295c90d94246abb2b951a91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#abe0862d80295c90d94246abb2b951a91">mIsLeaf</a></td></tr>
<tr class="memdesc:abe0862d80295c90d94246abb2b951a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-reference to containing level.  <a href="#abe0862d80295c90d94246abb2b951a91">More...</a><br/></td></tr>
<tr class="separator:abe0862d80295c90d94246abb2b951a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0966df9e5b094abc9bcab656c9c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a9b0966df9e5b094abc9bcab656c9c6bd">mMovables</a></td></tr>
<tr class="separator:a9b0966df9e5b094abc9bcab656c9c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b03dd60cac3277bcd2f2c262bae18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a844b03dd60cac3277bcd2f2c262bae18">mNumFaceGroups</a></td></tr>
<tr class="memdesc:a844b03dd60cac3277bcd2f2c262bae18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of face groups in this node if it is a leaf.  <a href="#a844b03dd60cac3277bcd2f2c262bae18">More...</a><br/></td></tr>
<tr class="separator:a844b03dd60cac3277bcd2f2c262bae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736c757eeb9cd899c511b9de8b43d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a9736c757eeb9cd899c511b9de8b43d37">mOwner</a></td></tr>
<tr class="separator:a9736c757eeb9cd899c511b9de8b43d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff118c3b93e2ced54e9345d96e87d384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#aff118c3b93e2ced54e9345d96e87d384">mSolidBrushes</a></td></tr>
<tr class="separator:aff118c3b93e2ced54e9345d96e87d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce6facb22a7c2363f48d9283de78632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1Plane.html">Plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#acce6facb22a7c2363f48d9283de78632">mSplitPlane</a></td></tr>
<tr class="memdesc:acce6facb22a7c2363f48d9283de78632"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plane which splits space in a non-leaf node.  <a href="#acce6facb22a7c2363f48d9283de78632">More...</a><br/></td></tr>
<tr class="separator:acce6facb22a7c2363f48d9283de78632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a374aa92008df8d65b33eb30c207d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#ad69a374aa92008df8d65b33eb30c207d">mVisCluster</a></td></tr>
<tr class="memdesc:ad69a374aa92008df8d65b33eb30c207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cluster number of this leaf.  <a href="#ad69a374aa92008df8d65b33eb30c207d">More...</a><br/></td></tr>
<tr class="separator:ad69a374aa92008df8d65b33eb30c207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8c663a45872e4b89850c3ba482beaef5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a8c663a45872e4b89850c3ba482beaef5">BspLevel</a></td></tr>
<tr class="separator:a8c663a45872e4b89850c3ba482beaef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1092a75e646a2cecdd62b54da97a09bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#a1092a75e646a2cecdd62b54da97a09bc">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> &amp;n)</td></tr>
<tr class="separator:a1092a75e646a2cecdd62b54da97a09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a node in a BSP tree. </p>
<p>A BSP tree represents space partitioned by planes . The space which is partitioned is either the world (in the case of the root node) or the space derived from their parent node. Each node can have elements which are in front or behind it, which are it's children and these elements can either be further subdivided by planes, or they can be undivided spaces or 'leaf nodes' - these are the nodes which actually contain objects and world geometry.The leaves of the tree are the stopping point of any tree walking algorithm, both for rendering and collision detection etc. <a class="el" href="namespaceOgre.html">Ogre</a> chooses not to represent splitting nodes and leaves as separate structures, but to merge the two for simplicity of the walking algorithm. If a node is a leaf, the <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> method returns true and both <a class="el" href="classOgre_1_1BspNode.html#a1a70415637b4144d7540113c8f0976bb" title="Returns a pointer to a BspNode containing the subspace on the positive side of the splitting plane...">getFront()</a> and <a class="el" href="classOgre_1_1BspNode.html#ac32f7f2ef7940f9f1236fdc6b17063ef" title="Returns a pointer to a BspNode containing the subspace on the negative side of the splitting plane...">getBack()</a> return null pointers. If the node is a partitioning plane <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false and <a class="el" href="classOgre_1_1BspNode.html#a1a70415637b4144d7540113c8f0976bb" title="Returns a pointer to a BspNode containing the subspace on the positive side of the splitting plane...">getFront()</a> and <a class="el" href="classOgre_1_1BspNode.html#ac32f7f2ef7940f9f1236fdc6b17063ef" title="Returns a pointer to a BspNode containing the subspace on the negative side of the splitting plane...">getBack()</a> will return the corresponding <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> objects. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00051">51</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af86ad5b76b6e2327db0e702d4216ad30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1set.html">set</a>&lt;const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>*&gt;::type <a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">Ogre::BspNode::IntersectingObjectSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00145">145</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ade6cf2f9bdd72538d3b2863bfb598f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1vector.html">vector</a>&lt;<a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a>*&gt;::type <a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">Ogre::BspNode::NodeBrushList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00152">152</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a39b74504f7252462d27f69bbeef5dc99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLeaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, only to be used by <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a>. </p>

</div>
</div>
<a class="anchor" id="a10395588ed29a1d34e3b028643dd2d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74871a4318ee6f0bfdf068a988bc2496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::~BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5702538be4c791af37cd73d2aa353a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspNode::_addMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable intersects it. </p>

</div>
</div>
<a class="anchor" id="aa10efd90b923c891eba69bad3b06d450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspNode::_removeMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable no longer intersects it. </p>

</div>
</div>
<a class="anchor" id="ac32f7f2ef7940f9f1236fdc6b17063ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getBack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> containing the subspace on the negative side of the splitting plane. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="ab257ed1ca61d08ca730acfdeb9d660c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&amp; Ogre::BspNode::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the axis-aligned box which contains this node if it is a leaf. </p>
<p>This method should only be called on a leaf node. It returns a box which can be used in calls like <a class="el" href="classOgre_1_1Camera.html#a2aa8b3916ca7beab3ec9654668be3703">Camera::isVisible</a> to determine if the leaf node is visible in the view. </p>

</div>
</div>
<a class="anchor" id="a210e41df7ecc16925b72a1be860eaf1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::BspNode::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the signed distance to the dividing plane. </p>

</div>
</div>
<a class="anchor" id="ac4d74a62b0962ada93a3354d502365a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getFaceGroupStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index to the face group index list for this leaf node. </p>
<p>The contents of this buffer is a list of indexes which point to the actual face groups held in a central buffer in the <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a> class (in actual fact for efficiency the indexes themselves are also held in a single buffer in <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a> too). The reason for this indirection is that the buffer of indexes to face groups is organised in chunks relative to nodes, whilst the main buffer of face groups may not be. Should only be called on a leaf node. </p>

</div>
</div>
<a class="anchor" id="a1a70415637b4144d7540113c8f0976bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getFront </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> containing the subspace on the positive side of the splitting plane. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a02ef32ad301c2cf1b427f762503b72a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getNextNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next node down in the tree, with the intention of locating the leaf containing the given point. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a0e24765e11c6b8efc03db7d1043070d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getNumFaceGroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of faces contained in this leaf node. </p>
<p>Should only be called on a leaf node. </p>

</div>
</div>
<a class="anchor" id="aa33233f828bbdf5b7160a70e463c4157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a>&amp; Ogre::BspNode::getObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00204">204</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

<p>References <a class="el" href="OgreBspNode_8h_source.html#l00200">mMovables</a>.</p>

</div>
</div>
<a class="anchor" id="a64fbeed3630e8bddb0ed3fba99f373c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a> Ogre::BspNode::getSide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which side of the splitting plane a worldspace point is. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="aeec9df00126e7fd14b6552788b8f5542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a>&amp; Ogre::BspNode::getSolidBrushes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main brush memory held on level. </p>
<pre class="fragment">Get the list of solid Brushes for this node.
</pre> <dl class="section remark"><dt>Remarks</dt><dd>Only applicable for leaf nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a138be75d58af8407ff8eb581ef1acead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1Plane.html">Plane</a>&amp; Ogre::BspNode::getSplitPlane </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns details of the plane which is used to subdivide the space of his node's children. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e.">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a5c3f25a54f243b0bed44f446e92af533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeaf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is a leaf (i.e. </p>
<p>contains geometry) or false if it is a splitting plane. A <a class="el" href="classOgre_1_1BspNode.html" title="Encapsulates a node in a BSP tree.">BspNode</a> can either be a splitting plane (the typical representation of a BSP node) or an undivided region contining geometry (a leaf node). <a class="el" href="namespaceOgre.html">Ogre</a> represents both using the same class for simplicity of tree walking. However it is important that you use this method to determine which type you are dealing with, since certain methods are only supported with one of the subtypes. Details are given in the individual methods. Note that I could have represented splitting / leaf nodes as a class hierarchy but the virtual methods / run-time type identification would have a performance hit, and it would not make the code much (any?) simpler anyway. I think this is a fair trade-off in this case. </p>

</div>
</div>
<a class="anchor" id="a851252ff648cb129cf8cb87cd7b45783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeafVisible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the passed in node (must also be a leaf) is visible from this leaf. </p>
<p>Must only be called on a leaf node, and the parameter must also be a leaf node. If this method returns true, then the leaf passed in is visible from this leaf. Note that internally this uses the Potentially Visible Set (PVS) which is precalculated and stored with the BSP level. </p>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00096">96</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00102">102</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00108">108</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00113">113</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00119">119</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00068">68</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00073">73</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00079">79</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00086">86</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00091">91</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8c663a45872e4b89850c3ba482beaef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00053">53</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1092a75e646a2cecdd62b54da97a09bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aaeaabf9f30966c28d7131a4e4d0f496b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::mBack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the node behind this non-leaf node. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00171">171</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a36a2fd9dac5864edd6169b3e9d188dda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> Ogre::BspNode::mBounds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The axis-aligned box which bounds node if it is a leaf. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00188">188</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac8268f4997a3e9d91fcd2a1f8aeee3b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mFaceGroupStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index to the part of the main leaf facegroup index buffer(held in BspLevel) for this leaf. </p>
<p>This leaf uses mNumFaceGroups from this pointer onwards. From here you use the index in this buffer to look up the actual face. Note that again for simplicity and bulk memory allocation the face group list itself is allocated by the <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a> for all nodes, and each leaf node is given a section of it to work on. This saves lots of small memory allocations / deallocations which limits memory fragmentation. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00198">198</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e71ff943c560f8603242f47db40478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::mFront</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the node in front of this non-leaf node. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00169">169</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe0862d80295c90d94246abb2b951a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::mIsLeaf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Back-reference to containing level. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00160">160</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b0966df9e5b094abc9bcab656c9c6bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a> Ogre::BspNode::mMovables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00200">200</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

<p>Referenced by <a class="el" href="OgreBspNode_8h_source.html#l00204">getObjects()</a>.</p>

</div>
</div>
<a class="anchor" id="a844b03dd60cac3277bcd2f2c262bae18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mNumFaceGroups</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of face groups in this node if it is a leaf. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00190">190</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9736c757eeb9cd899c511b9de8b43d37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a>* Ogre::BspNode::mOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00159">159</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff118c3b93e2ced54e9345d96e87d384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1BspNode.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a> Ogre::BspNode::mSolidBrushes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00202">202</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="acce6facb22a7c2363f48d9283de78632"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Plane.html">Plane</a> Ogre::BspNode::mSplitPlane</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The plane which splits space in a non-leaf node. </p>
<p>Note that nodes do not allocate the memory for other nodes - for simplicity and bulk-allocation of memory the <a class="el" href="classOgre_1_1BspLevel.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level.">BspLevel</a> is responsible for assigning enough memory for all nodes in one go. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00167">167</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad69a374aa92008df8d65b33eb30c207d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mVisCluster</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cluster number of this leaf. </p>
<p>Leaf nodes are assigned to 'clusters' of nodes, which are used to group nodes together for visibility testing. There is a lookup table which is used to determine if one cluster of leaves is visible from another cluster. Whilst it would be possible to expand all this out so that each node had a list of pointers to other visible nodes, this would be very expensive in terms of storage (using the cluster method there is a table which is 1-bit squared per cluster, rounded up to the nearest byte obviously, which uses far less space than 4-bytes per linked node per source node). Of course the limitation here is that you have to each leaf in turn to determine if it is visible rather than just following a list, but since this is only done once per frame this is not such a big overhead. </p>

<p>Definition at line <a class="el" href="OgreBspNode_8h_source.html#l00185">185</a> of file <a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreBspNode_8h_source.html">OgreBspNode.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<p>
Copyright &copy; 2012 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->
Last modified Mon Nov 25 2013 22:27:56
</p>
</body>
</html>
